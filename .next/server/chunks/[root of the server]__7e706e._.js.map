{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/xconfess/lib/mongodb.js"],"sourcesContent":["import { MongoClient } from \"mongodb\";\n\nconst uri = process.env.MONGODB_URI;\nconst options = {\n\tuseUnifiedTopology: true,\n\tuseNewUrlParser: true,\n};\n\nlet client;\nlet clientPromise;\n\nif (!process.env.MONGODB_URI) {\n\tthrow new Error(\"Add MONGODB_URI to .env file\");\n}\n\nif (process.env.NODE_ENV === \"development\") {\n\t// In development mode, use a global variable so the connection is not closed.\n\tif (!global._mongoClientPromise) {\n\t\tclient = new MongoClient(uri, options);\n\t\tglobal._mongoClientPromise = client.connect();\n\t}\n\tclientPromise = global._mongoClientPromise;\n} else {\n\t// In production, create a new client.\n\tclient = new MongoClient(uri, options);\n\tclientPromise = client.connect();\n}\n\nexport default clientPromise;\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,MAAM,QAAQ,GAAG,CAAC,WAAW;AACnC,MAAM,UAAU;IACf,oBAAoB;IACpB,iBAAiB;AAClB;AAEA,IAAI;AACJ,IAAI;AAEJ,IAAI,CAAC,QAAQ,GAAG,CAAC,WAAW,EAAE;IAC7B,MAAM,IAAI,MAAM;AACjB;AAEA,wCAA4C;IAC3C,8EAA8E;IAC9E,IAAI,CAAC,OAAO,mBAAmB,EAAE;QAChC,SAAS,IAAI,uGAAA,CAAA,cAAW,CAAC,KAAK;QAC9B,OAAO,mBAAmB,GAAG,OAAO,OAAO;IAC5C;IACA,gBAAgB,OAAO,mBAAmB;AAC3C,OAAO;;AAIP;uCAEe"}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/xconfess/app/api/register/route.js"],"sourcesContent":["import clientPromise from \"@/lib/mongodb\";\nimport { nanoid } from \"nanoid\";\nimport bcrypt from \"bcrypt\";\n\nexport async function POST(request) {\n\ttry {\n\t\tconst { username, gender, age, password } = await request.json();\n\n\t\tconst client = await clientPromise;\n\t\tconst db = client.db(\"xconfess\");\n\n\t\t// Check if username already exists\n\t\tconst existingUser = await db.collection(\"users\").findOne({ username });\n\n\t\tif (existingUser) {\n\t\t\treturn new Response(\n\t\t\t\tJSON.stringify({ error: \"Username already exists\" }),\n\t\t\t\t{ status: 400 }\n\t\t\t);\n\t\t}\n\n\t\t// Generate unique ID starting with 'XC'\n\t\tconst uniqueId = `XC${nanoid(10)}`;\n\n\t\t// Hash password\n\t\tconst passwordHash = await bcrypt.hash(password, 10);\n\n\t\t// Insert user into database\n\t\tconst result = await db.collection(\"users\").insertOne({\n\t\t\tuniqueId,\n\t\t\tusername,\n\t\t\tgender,\n\t\t\tage: age || null,\n\t\t\tpasswordHash,\n\t\t\tcreatedAt: new Date(),\n\t\t});\n\n\t\treturn new Response(\n\t\t\tJSON.stringify({\n\t\t\t\tmessage: \"User registered successfully\",\n\t\t\t\tuniqueId,\n\t\t\t}),\n\t\t\t{ status: 201 }\n\t\t);\n\t} catch (error) {\n\t\tconsole.error(error);\n\t\treturn new Response(\n\t\t\tJSON.stringify({ error: \"Internal Server Error\" }),\n\t\t\t{ status: 500 }\n\t\t);\n\t}\n}\n"],"names":[],"mappings":";;;AAAA;;;;;;AACA;;;;AAGO,eAAe,KAAK,OAAO;IACjC,IAAI;QACH,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG,MAAM,QAAQ,IAAI;QAE9D,MAAM,SAAS,MAAM,gHAAA,CAAA,UAAa;QAClC,MAAM,KAAK,OAAO,EAAE,CAAC;QAErB,mCAAmC;QACnC,MAAM,eAAe,MAAM,GAAG,UAAU,CAAC,SAAS,OAAO,CAAC;YAAE;QAAS;QAErE,IAAI,cAAc;YACjB,OAAO,IAAI,SACV,KAAK,SAAS,CAAC;gBAAE,OAAO;YAA0B,IAClD;gBAAE,QAAQ;YAAI;QAEhB;QAEA,wCAAwC;QACxC,MAAM,WAAW,CAAC,EAAE,EAAE,CAAA,GAAA,iJAAA,CAAA,SAAM,AAAD,EAAE,KAAK;QAElC,gBAAgB;QAChB,MAAM,eAAe,MAAM,OAAO,IAAI,CAAC,UAAU;QAEjD,4BAA4B;QAC5B,MAAM,SAAS,MAAM,GAAG,UAAU,CAAC,SAAS,SAAS,CAAC;YACrD;YACA;YACA;YACA,KAAK,OAAO;YACZ;YACA,WAAW,IAAI;QAChB;QAEA,OAAO,IAAI,SACV,KAAK,SAAS,CAAC;YACd,SAAS;YACT;QACD,IACA;YAAE,QAAQ;QAAI;IAEhB,EAAE,OAAO,OAAO;QACf,QAAQ,KAAK,CAAC;QACd,OAAO,IAAI,SACV,KAAK,SAAS,CAAC;YAAE,OAAO;QAAwB,IAChD;YAAE,QAAQ;QAAI;IAEhB;AACD"}},
    {"offset": {"line": 152, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}